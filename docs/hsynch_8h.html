<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Synch framework: hsynch.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_synch.png"/></td>
  <td id="projectalign">
   <div id="projectname">The Synch framework<span id="projectnumber">&#160;v3.1.3</span>
   </div>
   <div id="projectbrief">An open-source framework for concurrent data-structures and benchmarks</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_bba3cddd56565a95b77b098fd409d0ab.html">libconcurrent</a></li><li class="navelem"><a class="el" href="dir_3b0504cce330a6e867091f76f8160def.html">includes</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">hsynch.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This file exposes the API of the HSynch combining object. An example of use of this API is provided in benchmarks/hsynchbench.c file.  
<a href="#details">More...</a></p>

<p><a href="hsynch_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structHalfHSynchNode" id="r_structHalfHSynchNode"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hsynch_8h.html#structHalfHSynchNode">HalfHSynchNode</a></td></tr>
<tr class="memdesc:structHalfHSynchNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="hsynch_8h.html#structHalfHSynchNode" title="HalfHSynchNode should not be directly used by the user. It is internally used for proper alignment of...">HalfHSynchNode</a> should not be directly used by the user. It is internally used for proper alignment of the <a class="el" href="hsynch_8h.html#structHSynchNode" title="HSynchNode stores the data of an announced request.">HSynchNode</a> struct.  <a href="hsynch_8h.html#structHalfHSynchNode">More...</a><br /></td></tr>
<tr class="separator:structHalfHSynchNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structHSynchNode" id="r_structHSynchNode"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hsynch_8h.html#structHSynchNode">HSynchNode</a></td></tr>
<tr class="memdesc:structHSynchNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="hsynch_8h.html#structHSynchNode" title="HSynchNode stores the data of an announced request.">HSynchNode</a> stores the data of an announced request.  <a href="hsynch_8h.html#structHSynchNode">More...</a><br /></td></tr>
<tr class="separator:structHSynchNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:unionHSynchNodePtr" id="r_unionHSynchNodePtr"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hsynch_8h.html#unionHSynchNodePtr">HSynchNodePtr</a></td></tr>
<tr class="memdesc:unionHSynchNodePtr"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="hsynch_8h.html#unionHSynchNodePtr" title="HSynchNodePtr is a struct for padding pointers to nodes of requests.">HSynchNodePtr</a> is a struct for padding pointers to nodes of requests.  <a href="hsynch_8h.html#unionHSynchNodePtr">More...</a><br /></td></tr>
<tr class="separator:unionHSynchNodePtr"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structHSynchThreadState" id="r_structHSynchThreadState"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hsynch_8h.html#structHSynchThreadState">HSynchThreadState</a></td></tr>
<tr class="memdesc:structHSynchThreadState"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="hsynch_8h.html#structHSynchThreadState" title="HSynchThreadState stores each thread&#39;s local state for a single instance of HSynch....">HSynchThreadState</a> stores each thread's local state for a single instance of HSynch. For each instance of HSynch, a discrete instance of <a class="el" href="hsynch_8h.html#structHSynchThreadState" title="HSynchThreadState stores each thread&#39;s local state for a single instance of HSynch....">HSynchThreadState</a> should be used.  <a href="hsynch_8h.html#structHSynchThreadState">More...</a><br /></td></tr>
<tr class="separator:structHSynchThreadState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structHSynchStruct" id="r_structHSynchStruct"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hsynch_8h.html#structHSynchStruct">HSynchStruct</a></td></tr>
<tr class="memdesc:structHSynchStruct"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="hsynch_8h.html#structHSynchStruct" title="HSynchStruct stores the state of an instance of the a HSynch combining object. HSynchStruct should be...">HSynchStruct</a> stores the state of an instance of the a HSynch combining object. <a class="el" href="hsynch_8h.html#structHSynchStruct" title="HSynchStruct stores the state of an instance of the a HSynch combining object. HSynchStruct should be...">HSynchStruct</a> should be initialized using the HSynchStructInit function.  <a href="hsynch_8h.html#structHSynchStruct">More...</a><br /></td></tr>
<tr class="separator:structHSynchStruct"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab0c62b0836025c0499d9a5b624cd1870" id="r_ab0c62b0836025c0499d9a5b624cd1870"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hsynch_8h.html#ab0c62b0836025c0499d9a5b624cd1870">HSYNCH_DEFAULT_NUMA_POLICY</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ab0c62b0836025c0499d9a5b624cd1870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whenever numa_regions is equal to HSYNCH_DEFAULT_NUMA_POLICY, the user uses the default number of NUMA nodes, which is equal to the number of NUMA nodes that the machine provides. The information about machine's NUMA characteristics is provided by the functionality of numa.h lib. In case that numa_regions is different than HSYNCH_DEFAULT_NUMA_POLICY, the user overrides system's default number of NUMA nodes. For example, if numa_regions = 2 and the machine is equipped with 4 NUMA nodes,then the H-Synch will ignore this and will create a fictitious topology of 2 NUMA nodes. This is very useful in cases of machines that provide many NUMA nodes, but each each of them is equipped with a small amount of cores. In such a case, the combining degree of H-Synch may be restricted. Thus, creating a fictitious topology with restricted number of NUMA nodes gives much better performance. The user usually overrides HSYNCH_DEFAULT_NUMA_POLICY by setting the '-n' argument in the executable of the benchmarks.  <br /></td></tr>
<tr class="separator:ab0c62b0836025c0499d9a5b624cd1870"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ada46084b191eff9a8b238de7c02550d6" id="r_ada46084b191eff9a8b238de7c02550d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hsynch_8h.html#ada46084b191eff9a8b238de7c02550d6">HSynchStructInit</a> (<a class="el" href="hsynch_8h.html#structHSynchStruct">HSynchStruct</a> *l, uint32_t nthreads, uint32_t numa_regions)</td></tr>
<tr class="memdesc:ada46084b191eff9a8b238de7c02550d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes an instance of the HSynch combining object.  <br /></td></tr>
<tr class="separator:ada46084b191eff9a8b238de7c02550d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac123a40527fea5e90dea44499e294bca" id="r_ac123a40527fea5e90dea44499e294bca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hsynch_8h.html#ac123a40527fea5e90dea44499e294bca">HSynchThreadStateInit</a> (<a class="el" href="hsynch_8h.html#structHSynchStruct">HSynchStruct</a> *l, <a class="el" href="hsynch_8h.html#structHSynchThreadState">HSynchThreadState</a> *st_thread, int pid)</td></tr>
<tr class="memdesc:ac123a40527fea5e90dea44499e294bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function should be called once before the thread applies any operation to the HSynch combining object.  <br /></td></tr>
<tr class="separator:ac123a40527fea5e90dea44499e294bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3241c702af4cd3970f711482af76bf08" id="r_a3241c702af4cd3970f711482af76bf08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8h.html#a90de61a5a3c15d145ffc6403426befd3">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hsynch_8h.html#a3241c702af4cd3970f711482af76bf08">HSynchApplyOp</a> (<a class="el" href="hsynch_8h.html#structHSynchStruct">HSynchStruct</a> *l, <a class="el" href="hsynch_8h.html#structHSynchThreadState">HSynchThreadState</a> *st_thread, <a class="el" href="config_8h.html#a90de61a5a3c15d145ffc6403426befd3">RetVal</a>(*sfunc)(void *, <a class="el" href="config_8h.html#a0f12dac6e24575ca239f5605e28661ff">ArgVal</a>, int), void *state, <a class="el" href="config_8h.html#a0f12dac6e24575ca239f5605e28661ff">ArgVal</a> arg, int pid)</td></tr>
<tr class="memdesc:a3241c702af4cd3970f711482af76bf08"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called whenever a thread wants to apply an operation to the simulated concurrent object.  <br /></td></tr>
<tr class="separator:a3241c702af4cd3970f711482af76bf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file exposes the API of the HSynch combining object. An example of use of this API is provided in benchmarks/hsynchbench.c file. </p>
<dl class="section author"><dt>Author</dt><dd>Nikolaos D. Kallimanis (<a href="#" onclick="location.href='mai'+'lto:'+'nka'+'ll'+'ima'+'@g'+'mai'+'l.'+'com'; return false;">nkall<span class="obfuscator">.nosp@m.</span>ima@<span class="obfuscator">.nosp@m.</span>gmail<span class="obfuscator">.nosp@m.</span>.com</a>) </dd></dl>
<p>For a more detailed description see the original publication: Panagiota Fatourou, and Nikolaos D. Kallimanis."Revisiting the combining synchronization technique". ACM SIGPLAN Notices. Vol. 47. No. 8. ACM, PPoPP 2012. </p><dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2021 </dd></dl>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structHalfHSynchNode" id="structHalfHSynchNode"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structHalfHSynchNode">&#9670;&#160;</a></span>HalfHSynchNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct HalfHSynchNode</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p><a class="el" href="hsynch_8h.html#structHalfHSynchNode" title="HalfHSynchNode should not be directly used by the user. It is internally used for proper alignment of...">HalfHSynchNode</a> should not be directly used by the user. It is internally used for proper alignment of the <a class="el" href="hsynch_8h.html#structHSynchNode" title="HSynchNode stores the data of an announced request.">HSynchNode</a> struct. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a07ee60fd84f153f85b604bf114c4540c" name="a07ee60fd84f153f85b604bf114c4540c"></a>struct <a class="el" href="hsynch_8h.html#structHalfHSynchNode">HalfHSynchNode</a> *</td>
<td class="fieldname">
next</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a9b95d87484a19edadf32e2e5711059d3" name="a9b95d87484a19edadf32e2e5711059d3"></a><a class="el" href="config_8h.html#a0f12dac6e24575ca239f5605e28661ff">ArgVal</a></td>
<td class="fieldname">
arg_ret</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a0c0b6aea3ba319653fd05de2b400cc1e" name="a0c0b6aea3ba319653fd05de2b400cc1e"></a>uint32_t</td>
<td class="fieldname">
pid</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="ae8044130cff507c47205b3bc4c427238" name="ae8044130cff507c47205b3bc4c427238"></a>uint32_t</td>
<td class="fieldname">
locked</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a05f3315204ada94b7014c152b0d59767" name="a05f3315204ada94b7014c152b0d59767"></a>uint32_t</td>
<td class="fieldname">
completed</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structHSynchNode" id="structHSynchNode"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structHSynchNode">&#9670;&#160;</a></span>HSynchNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct HSynchNode</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p><a class="el" href="hsynch_8h.html#structHSynchNode" title="HSynchNode stores the data of an announced request.">HSynchNode</a> stores the data of an announced request. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a3637c44c2a226f377754fc9b0ea60261" name="a3637c44c2a226f377754fc9b0ea60261"></a>struct <a class="el" href="hsynch_8h.html#structHSynchNode">HSynchNode</a> *</td>
<td class="fieldname">
next</td>
<td class="fielddoc">
Pointer to the next request that has been announced. </td></tr>
<tr><td class="fieldtype">
<a id="a3f8275d9b38bb731bf874cf9a47de66c" name="a3f8275d9b38bb731bf874cf9a47de66c"></a><a class="el" href="config_8h.html#a0f12dac6e24575ca239f5605e28661ff">ArgVal</a></td>
<td class="fieldname">
arg_ret</td>
<td class="fielddoc">
This variable stores the argument of the request and the return value after the request is applied. </td></tr>
<tr><td class="fieldtype">
<a id="a2a958c5e73a23a697a7d9409ae534f36" name="a2a958c5e73a23a697a7d9409ae534f36"></a>uint32_t</td>
<td class="fieldname">
pid</td>
<td class="fielddoc">
The pid of the thread that announced this request. </td></tr>
<tr><td class="fieldtype">
<a id="a0d2bc696dc82a0e22e43d0f20343bbbf" name="a0d2bc696dc82a0e22e43d0f20343bbbf"></a>uint32_t</td>
<td class="fieldname">
locked</td>
<td class="fielddoc">
Whenever it is equal to false, the thread is the combiner; otherwise the thread waits until a combiner apply its request. </td></tr>
<tr><td class="fieldtype">
<a id="a761d976428c6eaeac2fd6ca1f8039ab8" name="a761d976428c6eaeac2fd6ca1f8039ab8"></a>uint32_t</td>
<td class="fieldname">
completed</td>
<td class="fielddoc">
If true, the request is applied and the thread returns its return value. </td></tr>
<tr><td class="fieldtype">
<a id="a8c1668c3cc984dcd23f29fb3dbd62819" name="a8c1668c3cc984dcd23f29fb3dbd62819"></a>char</td>
<td class="fieldname">
align[PAD_CACHE(sizeof(<a class="el" href="hsynch_8h.html#structHalfHSynchNode">HalfHSynchNode</a>))]</td>
<td class="fielddoc">
Padding space. </td></tr>
</table>

</div>
</div>
<a name="unionHSynchNodePtr" id="unionHSynchNodePtr"></a>
<h2 class="memtitle"><span class="permalink"><a href="#unionHSynchNodePtr">&#9670;&#160;</a></span>HSynchNodePtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union HSynchNodePtr</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p><a class="el" href="hsynch_8h.html#unionHSynchNodePtr" title="HSynchNodePtr is a struct for padding pointers to nodes of requests.">HSynchNodePtr</a> is a struct for padding pointers to nodes of requests. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ac110972c63a63f3123b2e9aa70f57528" name="ac110972c63a63f3123b2e9aa70f57528"></a>volatile <a class="el" href="hsynch_8h.html#structHSynchNode">HSynchNode</a> *</td>
<td class="fieldname">
ptr</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a45ebdc2d5d369e3eab63a007fff892de" name="a45ebdc2d5d369e3eab63a007fff892de"></a>char</td>
<td class="fieldname">
pad[CACHE_LINE_SIZE]</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structHSynchThreadState" id="structHSynchThreadState"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structHSynchThreadState">&#9670;&#160;</a></span>HSynchThreadState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct HSynchThreadState</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p><a class="el" href="hsynch_8h.html#structHSynchThreadState" title="HSynchThreadState stores each thread&#39;s local state for a single instance of HSynch....">HSynchThreadState</a> stores each thread's local state for a single instance of HSynch. For each instance of HSynch, a discrete instance of <a class="el" href="hsynch_8h.html#structHSynchThreadState" title="HSynchThreadState stores each thread&#39;s local state for a single instance of HSynch....">HSynchThreadState</a> should be used. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a6d7b1a3fdd3f92d6bae43ad4aac03301" name="a6d7b1a3fdd3f92d6bae43ad4aac03301"></a><a class="el" href="hsynch_8h.html#structHSynchNode">HSynchNode</a> *</td>
<td class="fieldname">
next_node</td>
<td class="fielddoc">
pointer to an empty request that would be used for announcing future requests. </td></tr>
</table>

</div>
</div>
<a name="structHSynchStruct" id="structHSynchStruct"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structHSynchStruct">&#9670;&#160;</a></span>HSynchStruct</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct HSynchStruct</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p><a class="el" href="hsynch_8h.html#structHSynchStruct" title="HSynchStruct stores the state of an instance of the a HSynch combining object. HSynchStruct should be...">HSynchStruct</a> stores the state of an instance of the a HSynch combining object. <a class="el" href="hsynch_8h.html#structHSynchStruct" title="HSynchStruct stores the state of an instance of the a HSynch combining object. HSynchStruct should be...">HSynchStruct</a> should be initialized using the HSynchStructInit function. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a514dffb991528ee8989dcb9427304fe1" name="a514dffb991528ee8989dcb9427304fe1"></a>int32_t *</td>
<td class="fieldname">
node_indexes</td>
<td class="fielddoc">
Used for constructing the Numa topology. </td></tr>
<tr><td class="fieldtype">
<a id="a219e71331158e69c033925c915cba834" name="a219e71331158e69c033925c915cba834"></a>uint32_t</td>
<td class="fieldname">
nthreads</td>
<td class="fielddoc">
The number of threads that will use the HSynch combining object. </td></tr>
<tr><td class="fieldtype">
<a id="a0a4715716181c74f0e821adb84414bcd" name="a0a4715716181c74f0e821adb84414bcd"></a>uint32_t</td>
<td class="fieldname">
numa_node_size</td>
<td class="fielddoc">
The size in terms of processing elements that each Numa node has. </td></tr>
<tr><td class="fieldtype">
<a id="a64ea31ae8fa4cfe31a1cbe0e835eb885" name="a64ea31ae8fa4cfe31a1cbe0e835eb885"></a>uint32_t</td>
<td class="fieldname">
numa_nodes</td>
<td class="fielddoc">
The number of Numa nodes. </td></tr>
<tr><td class="fieldtype">
<a id="a3a42694316e5bf9ac45cde3447277df8" name="a3a42694316e5bf9ac45cde3447277df8"></a>bool</td>
<td class="fieldname">
numa_policy</td>
<td class="fielddoc">
The numa policy that the system follows. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ab0c62b0836025c0499d9a5b624cd1870" name="ab0c62b0836025c0499d9a5b624cd1870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c62b0836025c0499d9a5b624cd1870">&#9670;&#160;</a></span>HSYNCH_DEFAULT_NUMA_POLICY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HSYNCH_DEFAULT_NUMA_POLICY&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whenever numa_regions is equal to HSYNCH_DEFAULT_NUMA_POLICY, the user uses the default number of NUMA nodes, which is equal to the number of NUMA nodes that the machine provides. The information about machine's NUMA characteristics is provided by the functionality of numa.h lib. In case that numa_regions is different than HSYNCH_DEFAULT_NUMA_POLICY, the user overrides system's default number of NUMA nodes. For example, if numa_regions = 2 and the machine is equipped with 4 NUMA nodes,then the H-Synch will ignore this and will create a fictitious topology of 2 NUMA nodes. This is very useful in cases of machines that provide many NUMA nodes, but each each of them is equipped with a small amount of cores. In such a case, the combining degree of H-Synch may be restricted. Thus, creating a fictitious topology with restricted number of NUMA nodes gives much better performance. The user usually overrides HSYNCH_DEFAULT_NUMA_POLICY by setting the '-n' argument in the executable of the benchmarks. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ada46084b191eff9a8b238de7c02550d6" name="ada46084b191eff9a8b238de7c02550d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada46084b191eff9a8b238de7c02550d6">&#9670;&#160;</a></span>HSynchStructInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HSynchStructInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hsynch_8h.html#structHSynchStruct">HSynchStruct</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nthreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numa_regions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes an instance of the HSynch combining object. </p>
<p>This function should be called once (by a single thread) before any other thread tries to apply any request by using the HSynchApplyOp function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>A pointer to an instance of the HSynch combining object. </td></tr>
    <tr><td class="paramname">nthreads</td><td>The number of threads that will use the HSynch combining object. </td></tr>
    <tr><td class="paramname">numa_regions</td><td>The number of Numa nodes (which may differ with the actual hw numa nodes) that H-Synch should consider. In case that numa_nodes is equal to HSYNCH_DEFAULT_NUMA_POLICY, the number of Numa nodes provided by the HW is used (see more on <a class="el" href="hsynch_8h.html" title="This file exposes the API of the HSynch combining object. An example of use of this API is provided i...">hsynch.h</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac123a40527fea5e90dea44499e294bca" name="ac123a40527fea5e90dea44499e294bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac123a40527fea5e90dea44499e294bca">&#9670;&#160;</a></span>HSynchThreadStateInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HSynchThreadStateInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hsynch_8h.html#structHSynchStruct">HSynchStruct</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="hsynch_8h.html#structHSynchThreadState">HSynchThreadState</a> *&#160;</td>
          <td class="paramname"><em>st_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function should be called once before the thread applies any operation to the HSynch combining object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>A pointer to an instance of the HSynch combining object. </td></tr>
    <tr><td class="paramname">st_thread</td><td>A pointer to thread's local state of HSynch. </td></tr>
    <tr><td class="paramname">pid</td><td>The pid of the calling thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3241c702af4cd3970f711482af76bf08" name="a3241c702af4cd3970f711482af76bf08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3241c702af4cd3970f711482af76bf08">&#9670;&#160;</a></span>HSynchApplyOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8h.html#a90de61a5a3c15d145ffc6403426befd3">RetVal</a> HSynchApplyOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hsynch_8h.html#structHSynchStruct">HSynchStruct</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="hsynch_8h.html#structHSynchThreadState">HSynchThreadState</a> *&#160;</td>
          <td class="paramname"><em>st_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config_8h.html#a90de61a5a3c15d145ffc6403426befd3">RetVal</a>(*)(void *, <a class="el" href="config_8h.html#a0f12dac6e24575ca239f5605e28661ff">ArgVal</a>, int)&#160;</td>
          <td class="paramname"><em>sfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config_8h.html#a0f12dac6e24575ca239f5605e28661ff">ArgVal</a>&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called whenever a thread wants to apply an operation to the simulated concurrent object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>A pointer to an instance of the HSynch combining object. </td></tr>
    <tr><td class="paramname">st_thread</td><td>A pointer to thread's local state for a specific instance of HSynch. </td></tr>
    <tr><td class="paramname">sfunc</td><td>A serial function that the HSynch instance should execute, while applying requests announced by active threads. </td></tr>
    <tr><td class="paramname">state</td><td>A pointer to the state of the simulated object. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument of the request that the thread wants to apply. </td></tr>
    <tr><td class="paramname">pid</td><td>The pid of the calling thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RetVal The return value of the applied request. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>

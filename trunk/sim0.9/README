This preliminary code is highly optimized for x86_64
machine architecture. Notice that files sim.c, simstack.c
and simqueue.c are running much better in a X86_64 machine,
SPARC machines do not support Fetch&Multiply instrucctions.
Compiling or running the code in other architectures it could 
be impossible or it could give poor performance.
The code is developed and tested in an AMD ccNUMA machine
equpied with 4 8-core processors (magny cours). 
For best source code compatibility use 
a gcc compiler of version 4.3.0 or greater. Although, some
newer versions of suncc compiler are experimentally supported.
In order to achieve the best performance for each implemented
algorithm choose carefully the backoff upper and lower bounds.
Notice that backoff bounds are highly dependent from the exact
configuration of your system (number of threads running, number 
of cores used, etc.). Furthermore, changes in Makefile 
may needed. In order to compile your files execute
in a command prompt "make X86" for X86_64 machines and 
"make SPARC" for SPARC machines. By running command 
"./bench.sh XYZ.run", you will bw able to run file XYZ.run
10 times and its average performance will be printed.
Before running any experiment, have a look at config.h. 
It is of major importance to appropriate configure some
parameters of your configuration (i.e. number of threads,
number of cores that your machine is equipped, etc). Use this
code with your own responsibility, no gurantee is provided.


For any further information do not hesitate to send an email 
to nkallima (at) cs.uoi.gr



FILE            EXPERIMENT
------------------------------------------------------------------------
sim.c           Simulates a wait-free Fetch&Multiply atomic object using 
                Sim algorithm.
simstack.c      Simulates a wait-free atomic stack using an instance of 
                Sim algorithm.
simqueue.c      Simulates a wait-free atomic queue using two instances
                of Sim algorithm.


lfstack.c       This is a lock free implementation of a shared stack.
msqueue.c       This is a lock free queue implementation using the
                algorithm presented by Maged M. Michael and
                Michael L. Scott, PODC '96
lfuobject.c     A lock free implementation of Fetch&Multiply object.



luobject.c      An implementation of Fetch&Multiply using high
                performance spin-locks.
locksstack.c    An implementation of shared stack using high
                performance spin-locks.
locksqueue.c    An implementation of shared queue using high
                performance spin-locks.



bench.sh        A simple shell script for extracting performance numbers
                for each of the above algorithms. Some algorithms do not
                need any parameter. Some of them may need backoff 
                upper/lower bounds as parameters.
Makefile        It just copiles all the files. In order to run 
                benchmark, it is better to use bench.sh script.
